# The provision job boots up the new ec2 instance for deploying MLReef
provision:
  stage: provision
#  rules:
#    # Only execute the provisioning if no environment URL is set
#    - if: '$CI_ENVIRONMENT_URL == ""' # This rule will be evaluated
#      when: always
  image: registry.gitlab.com/systemkern/s5:latest-aws
  variables:
    EC2_MACHINE_SIZE:     "t3a.medium"                       # https://aws.amazon.com/ec2/instance-types/
    EC2_MACHINE_SIZE_DEV: "p2.xlarge"                        # https://aws.amazon.com/ec2/instance-types/
    #EC2_IMAGE_AMI:     "ami-061aaaac62de85935"              # Deep Learning AMI (Ubuntu 18.04) Version 28.1
    EC2_IMAGE_AMI:      "ami-00c3243b989d3d9c9"              # Deep Learning AMI (Ubuntu 16.04) Version 28.1
    EC2_SECURITY_GRP:     "application-servers"
    EC2_INSTANCE_NAME:    "mlreef-$CI_COMMIT_REF_SLUG"       # environment name and url are set separately
    STARTUP_SCRIPT:       "src/bin/startup.sh"               # used in .gitlab-ci-deploy.yml and docker-compose.yml
  before_script:
    - chmod 400 $SSH_KEYFILE                                # prepare private key file
    - if [ "$CI_COMMIT_REF_SLUG" == "develop" ]; then EC2_MACHINE_SIZE=$EC2_MACHINE_SIZE_DEV; fi
    - echo "$EC2_INSTANCE_NAME"
    - echo "$EC2_MACHINE_SIZE"
    - echo "$CI_ENVIRONMENT_URL"
    - echo "$DYNAMIC_ENVIRONMENT_URL"

  script:
    - aws ec2 describe-instances --filters "Name=tag:Name,Values=$EC2_INSTANCE_NAME"
      | jq -r ".Reservations[].Instances[].NetworkInterfaces[].Association.PublicDnsName"
      | tr -d '\r' > $INSTANCE_INFO

    - if [ "$(cat $INSTANCE_INFO)" != "" ]; then
        echo "Found an existing environment which will be recycled";
        exit 0;
        fi
    - echo "Could not find an existing environment, provisioning a new one";

    - sed -i "s~AWS_ACCESS_KEY_ID=XXXXX~AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID~"                 $STARTUP_SCRIPT
    - sed -i "s~AWS_SECRET_ACCESS_KEY=XXXXX~AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY~"     $STARTUP_SCRIPT
    # aws ec2 run instances documentation
    # https://docs.aws.amazon.com/cli/latest/reference/ec2/run-instances.html
    #   --credit-specification CpuCredits=standard
    - aws ec2 run-instances --count 1
      --region ${AWS_DEFAULT_REGION}
      --image-id ${EC2_IMAGE_AMI}
      --instance-type ${EC2_MACHINE_SIZE}
      --security-groups ${EC2_SECURITY_GRP}
      --key-name development
      --user-data file://"${STARTUP_SCRIPT}"
      --block-device-mappings file://$DEVICE_MAPPINGS
      --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=$EC2_INSTANCE_NAME}]"
      | jq -r ".Instances[].InstanceId"
      | xargs --no-run-if-empty -I {} aws ec2 describe-instances --filters "Name=instance-id,Values={}"
      | jq -r ".Reservations[].Instances[].NetworkInterfaces[].Association.PublicDnsName"
      | tr -d '\r' > $INSTANCE_INFO                        # pass instance url to deploy stage
  after_script:
    - cat $INSTANCE_INFO                                   # debug output
  artifacts:
    paths:
      - $INSTANCE_INFO                                     # Pass the dotenv file to later stages
  environment:
    name: $CI_COMMIT_REF_SLUG
    url: $CI_PIPELINE_URL
    on_stop: stop review                                   # clean up after branch merge



gitlab env config:
  extends: [".except-docu-branches"]
  image: registry.gitlab.com/systemkern/s5:latest
  stage: deploy
  variables:
    KEY: "Authorization:"                                  # workaround to preserver the yaml structure
  before_script:
    - URL=$(cat $INSTANCE_INFO)
    - echo $URL                                            # debug output
  script:
    # Get the ID of the gitlab environment we want to edit
    - ID=$(curl --fail
      --header "$KEY Bearer $GITLAB_API_TOKEN"
      https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/environments?name=$CI_COMMIT_REF_SLUG
      | jq -c '.[] | select(.name | contains("'$CI_REF_SLUG'")) | .id'
      )
    - echo "ID is $ID"                                      # debug output
    # configure the gitlab environment with the correct URL
    - curl --request PUT --fail
      --header "$KEY Bearer $GITLAB_API_TOKEN"
      --data "name=$CI_COMMIT_REF_SLUG&external_url=http://$URL"
      https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/environments/$ID


# The decommission job is configured by the provision's job `on_stop` command.
# The execution of decommission is triggered by merging or deleting a branch.
# https://docs.gitlab.com/ee/ci/environments.html#automatically-stopping-an-environment
stop review:
  extends: [".feature-branches-only"]
  stage: maintenance                                       # The decommission job must be in the same stage as the feature branch provisionjob in order for the environment to automatically stop
  when: manual
  image: registry.gitlab.com/systemkern/s5:latest-aws
  variables:
    GIT_STRATEGY: "none"                                   # because branches are deleted on merge, we must not access the git repo
    # workaround for YAML structure incompatibility https://gitlab.com/gitlab-org/gitlab-runner/issues/1809
    WORKAROUND: "PRIVATE-TOKEN:"                           # workaround to not break the yaml structure
  script:
    # decommission the current environment
    # use the aws-cli to retrieve the description (json) for our machine
    # parse the json with jq to get the instance id
    # the xargs command submits the termination command to AWS
    - aws ec2 describe-instances --filters "Name=tag:Name,Values=$EC2_INSTANCE_NAME"
      | jq -r ".Reservations[].Instances[].InstanceId"
      | xargs --no-run-if-empty aws ec2 terminate-instances --instance-id

    # remove the branch's frontend docker container
    - echo "Delete URL is https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/registry/repositories/$DOCKER_REGISTRY_REPO/tags/$CI_COMMIT_REF_SLUG/"
    - curl --request DELETE --header "$WORKAROUND $GITLAB_API_TOKEN" --fail
      https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/registry/repositories/$DOCKER_REGISTRY_REPO/tags/$CI_COMMIT_REF_SLUG
  after_script:
    # remove the data backup from s3 (if it exists)
    - aws s3 rm "s3://$S3_DATA_BUCKET/mlreef-data-$CI_COMMIT_REF_SLUG.zip"
  environment:
    name: $CI_COMMIT_REF_SLUG
    action: stop
