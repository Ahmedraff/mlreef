#!/bin/bash
# change directory scripts location
cd "$(dirname "$0")"
########################################
# set -x  # output all commands
set -o pipefail
set -e # exit on immediately on every error
set -u # error on usage of undefined variables
########################################

function sigterm_handler() {
  echo "SIGTERM signal received, try to gracefully shutdown all services..."
  gitlab-ctl stop
  exit
}
trap "sigterm_handler; exit" TERM

log() {
  echo "### $(date +%Y-%m-%d\ %H:%M:%S) ### $1"
}

recreateGitlabAdminToken() {
  # http://gitlab.com/help/administration/troubleshooting/gitlab_rails_cheat_sheet.md
  # Deleting all API tokens for root user (id=1)
  gitlab-rails runner -e production "
    User.find(1).personal_access_tokens.each do |cur|
      cur.delete
    end
  "
  #Creating Admin API token $GITLAB_ADMIN_TOKEN. This might take up to 5 minutes
  gitlab-rails runner -e production "User.find(1).personal_access_tokens.create(
    name: 'mlreef-backend-api-token $(date +%Y-%m-%d\ %H:%M:%S)',
    token_digest: Gitlab::CryptoHelper.sha256('$GITLAB_ADMIN_TOKEN'),
    impersonation: false,
    scopes: [:api,:sudo]
  )"
}

getGitlabRunnerRegistrationToken() {
  gitlab-rails runner -e production "puts Gitlab::CurrentSettings.current_application_settings.runners_registration_token" | tr -d '\r'
}

#########################
# Call the Gitlab wrapper
# Gitlab will self-daemonize and run in the background hence no '&' is needed
log "booting and configuring Gitlab ..."
/assets/gitlab-wrapper >/dev/null

log "Refreshing root user api-token"
recreateGitlabAdminToken

log "Getting Gitlab runners registration token from Gitlab."
RUNNER_REGISTRATION_TOKEN=$(getGitlabRunnerRegistrationToken)

log "GITLAB_RUNNER_REGISTRATION_TOKEN=$RUNNER_REGISTRATION_TOKEN"
log "Gitlab is ready"

#########################
# Setup gitlab-runner
GITLAB_PORT=10080
# Wait for Gitlab to enable the database
touch /var/log/configuration.lock
touch /var/log/configuration.log
{
  echo "### $(date) Waiting for Gitlab Runners API. The runners API is running in a separate process from the normal API"
  until [ "$(curl --silent --output /dev/null -w ''%{http_code}'' localhost:${GITLAB_PORT}/runners)" = "302" ]; do
    printf '.'
    sleep 5;
  done
  echo "### $(date) Expecting code 302; received: $(curl --silent --output /dev/null -w ''%{http_code}'' localhost:${GITLAB_PORT}/runners)"

  echo "### Getting Gitlab runners registration token from Gitlab."
  TOKEN=$(gitlab-rails runner -e production "puts Gitlab::CurrentSettings.current_application_settings.runners_registration_token" | tr -d '\r')
  echo TOKEN="$TOKEN"


  echo "### Configuring gitlab runner for localhost:$GITLAB_PORT"

  gitlab-runner register --non-interactive \
    --url="http://localhost:${GITLAB_PORT}/" \
    --registration-token "$TOKEN" \
    --executor "docker" \
    --docker-image alpine:latest \
    --docker-privileged="true"   \
    --description "Packaged Runner"  \
    --tag-list "docker,local-docker" \
    --run-untagged="true" \
    --locked="false" \
    --access-level="not_protected"

  gitlab-runner start

} >/var/log/configuration.log
rm -f /var/log/configuration.lock

##################################
# Local registry EPF image upload
# Setup mlreef project
# Gitlab local group and project creation
export GITLAB_ROOTGROUP=mlreef-group
export GITLAB_PROJECT=mlreef

# Creating root group
rootGroupId=$(curl --header "PRIVATE-TOKEN: $GITLAB_ADMIN_TOKEN" "${INSTANCE_HOST}:${GITLAB_PORT}/api/v4/groups?search=$GITLAB_ROOTGROUP" | jq -M 'map(select(.name == "'$GITLAB_ROOTGROUP'"))| .[0].id' )
if [ $rootGroupId == "null" ]; then
  rootGroupId=$(curl --request POST --header "PRIVATE-TOKEN: $GITLAB_ADMIN_TOKEN" --header "Content-Type: application/json" \
  --data '{"path": "'$GITLAB_ROOTGROUP'", "name": "'$GITLAB_ROOTGROUP'", "visibility": "public" ,"lfs_enabled": "true" , "description": "Root Group" }' \
  "${INSTANCE_HOST}:${GITLAB_PORT}/api/v4/groups/" | jq '.["id"]')
fi
echo "Root group Id: $rootGroupId"
# Project creation
projectId=$(curl "${INSTANCE_HOST}:${GITLAB_PORT}/api/v4/groups/$rootGroupId/projects?search=$GITLAB_PROJECT" -H "PRIVATE-TOKEN: $GITLAB_ADMIN_TOKEN" | jq -M 'map(select(.name == "'$GITLAB_PROJECT'"))| .[0].id'  )
if [ $projectId == "null" ]; then
  projectId=$(curl --request POST --header "PRIVATE-TOKEN: $GITLAB_ADMIN_TOKEN" --header "Content-Type: application/json" \
  --data '{"path": "'$GITLAB_PROJECT'", "namespace_id": "'$rootGroupId'", "visibility": "public"}' \
  "${INSTANCE_HOST}:${GITLAB_PORT}/api/v4/projects/" | jq '.["id"]')
fi
echo "Project Id: $projectId" 

# Local EPF image upload
export LOCAL_CI_REGISTRY_USER=root
export LOCAL_CI_REGISTRY_IMAGE="${LOCAL_REGISTRY_EXTERNAL_URL}/${GITLAB_ROOTGROUP}/${GITLAB_PROJECT}"
export LOCAL_EPF_IMAGE_PATH=$LOCAL_CI_REGISTRY_IMAGE/epf:latest

if [ -n "${LOCAL_REGISTRY_EXTERNAL_URL+x}" ] && [ -n "${LOCAL_CI_REGISTRY_USER+x}" ] && [ -n "${GITLAB_ADMIN_TOKEN+x}" ]; then
          echo "$GITLAB_ADMIN_TOKEN" | docker login "$LOCAL_REGISTRY_EXTERNAL_URL" --username="$LOCAL_CI_REGISTRY_USER" --password-stdin
fi

docker build --tag "$LOCAL_EPF_IMAGE_PATH" -f epf/Dockerfile epf
docker push "$LOCAL_EPF_IMAGE_PATH"
log "$LOCAL_EPF_IMAGE_PATH has been successfully uploaded "


#########################
# Start the PostgreSQL mlreefdb server
# Postgres will self-daemonize and run in the background hence no '&' is needed
log "starting MLReef database"
pg_ctlcluster 11 main start

#########################
# Start the backend
# using "&" to run the process in the background
log "starting MLReef backend..."
java -cp /app:/app/lib/* com.mlreef.rest.RestApplicationKt &

########################
# Start the API Gateway
# NGINX will self-daemonize and run in the background hence no '&' is needed
/usr/sbin/nginx

########################
# keep Docker container alive
tail -f /dev/null
# Wait for SIGTERM
wait

#Bring the first process to foreground
fg %1

