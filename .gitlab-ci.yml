include:
  - local: backend/.gitlab-ci.yml
  - local: epf/.gitlab-ci.yml
  - local: web/.gitlab-ci.yml

stages:
  - build
  - deploy
  - test
  - staging
  - maintenance

variables:
  S3_DATA_BUCKET:       "mlreef-application-data"          # see also ec2 startup script
  DATA_ARCHIVE:         "mlreef-data-develop.zip"

.except-docu-branches:
  except:
    variables:
      # $CI_COMMIT_REF_NAME is the complete branch name e.g. "feature/my-cool-new-branch"
      - $CI_COMMIT_REF_NAME =~ /^doc\//                    # match every branch "doc/**"
      - $CI_COMMIT_REF_NAME =~ /^docs\//                   # match every branch "docs/**"
      - $CI_COMMIT_REF_NAME =~ /^docu\//                   # match every branch "docu/**"
      - $CI_COMMIT_REF_NAME =~ /^documentation\//          # match every branch "documentation/**"
      - $CI_COMMIT_REF_NAME =~ /^site\//                   # match every branch "site/**"

.feature-branches-only:
  extends: [".except-docu-branches"]
  except:
    refs:
      - develop
      - master

# provision boots up the new ec2 instance for deploying MLReef
provision:
  extends: [".except-docu-branches"]
  stage: build
  image: registry.gitlab.com/systemkern/s5:latest-aws
  script: bin/ci-provision
  artifacts:
    paths:
      - out/instance.info                                  # pass instance url to later stages (see bin/includes/ci-environment)
  environment:
    name: $CI_COMMIT_REF_SLUG
    url: $CI_PIPELINE_URL
    on_stop: decommission                                  # clean up after branch merge


gitlab env config:
  extends: [".except-docu-branches"]
  stage: deploy
  image: registry.gitlab.com/systemkern/s5:latest
  script:
    - URL=$(cat out/instance.info)
    - echo $URL                                            # debug output
    # Get the ID of the gitlab environment we want to edit
    - ID=$(curl --fail
      --header "Authorization:Bearer $GITLAB_COM_API_TOKEN"
      https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/environments?name=$CI_COMMIT_REF_SLUG
      | jq -c '.[] | select(.name | contains("'$CI_REF_SLUG'")) | .id'
      )
    - echo "ID is $ID"                                     # debug output
    # configure the gitlab environment with the correct URL
    - curl --request PUT --fail
      --header "Authorization:Bearer $GITLAB_COM_API_TOKEN"
      --data "name=$CI_COMMIT_REF_SLUG&external_url=http://$URL/login"
      https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/environments/$ID


deploy:
  extends: [".except-docu-branches"]
  stage: deploy
  only:
    changes:
      - backend/**/*
      - bin/ci-deploy
      - epf/**/*
      - web/**/*
      - docker-compose.yml
  when: delayed
  start_in: 3 minutes                                                 # Give new ec2 environments enough time to boot
  image: registry.gitlab.com/systemkern/s5:latest
  script: bin/ci-deploy

# please do not move, adapt, delete, move to a include, whatever, if you did not read about the special "pages" job of gitlab ci
pages:
  image: node:10.19.0-alpine                                # https://hub.docker.com/_/node/
  stage: deploy
  only:
    changes:
      - backend/**/*
      - docs/**/*
      - README.md
  cache:
    key: pages-public-cache
    paths:
      - public/
      - /usr/local/lib/node_modules
      - docs/node_modules
  script: docs/bin/ci-pages
  artifacts:
    paths:
      - public


gitlab api smoke test:
  extends: [.except-docu-branches]
  stage: test
  when: delayed
  start_in: 4 minutes
  image: registry.gitlab.com/systemkern/s5:latest
  # Gitlab Runners are a separate process from Gitlab's API and Gitlab's frontend
  script: |
    URL=$(cat out/instance.info)
    echo $URL                                            # debug output
    if [ $(curl --silent --output /dev/null -w ''%{http_code}'' $URL/api/v4/projects) != 200 ]; then
      curl $URL/api/v4/projects
      exit 1;
    fi


postman test suite:
  extends: [.except-docu-branches]
  stage: test
  only:
    changes:
      - backend/**/*
  when: delayed
  start_in: 4 minutes
  image: registry.gitlab.com/systemkern/s5:latest-newman
  cache:
    key: newman
    paths:
      - node_modules/.bin/
  script: bin/ci-postman-tests


e2e test experiment:
  allow_failure: true
  extends: [.except-docu-branches]
  stage: test
  only:
    changes:
      - backend/**/*
      - bin/tests/**/***
      - bin/ci-test-end2end-experiment
      - epf/**/*
  when: delayed
  start_in: 4 minutes
  image: registry.gitlab.com/systemkern/s5:latest-git
  script: bin/ci-test-end2end-experiment
  artifacts:
    paths:
      - out/test


test rest docs are present:
  extends: [.except-docu-branches]
  stage: test
  image: registry.gitlab.com/systemkern/s5:latest
  # See docu/bin/ci-pages for the exact path to where rest docs are deployed
  script: |
    echo "Testing if backend rest-docs are available at https://mlreef.gitlab.io/mlreef/rest-api/$CI_COMMIT_BRANCH/index.html"
    curl --fail --GET "https://mlreef.gitlab.io/mlreef/rest-api/$CI_COMMIT_BRANCH/index.html" > /dev/null


staging:
  stage: staging
  only:
    refs:
      - master
  trigger: mlreef/infrastructure


# The decommission job is configured by the provision's job `on_stop` command.
# The execution of decommission is triggered by merging or deleting a branch.
# https://docs.gitlab.com/ee/ci/environments.html#automatically-stopping-an-environment
decommission:
  extends: [".feature-branches-only"]
  stage: maintenance
  when: manual
  image: registry.gitlab.com/systemkern/s5:latest-aws
  variables:
    GIT_STRATEGY: "none"                                    # because branches are deleted on merge, we must not access the git repo
  script:
    - EC2_INSTANCE_NAME="mlreef-$CI_COMMIT_REF_SLUG"

    # decommission the current environment
    # use the aws-cli to retrieve the description (json) for our machine
    # parse the json with jq to get the instance id
    # the xargs command submits the termination command to AWS
    - aws ec2 describe-instances --filters "Name=tag:Name,Values=$EC2_INSTANCE_NAME"
      | jq -r ".Reservations[].Instances[].InstanceId"
      | xargs --no-run-if-empty aws ec2 terminate-instances --instance-id

    # remove the branch's frontend docker container
    # 1117031 is the id of the "gateway's" sub-repository id
    - curl --request DELETE --header "PRIVATE-TOKEN:$GITLAB_COM_API_TOKEN"
      https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/registry/repositories/1117031/tags/$CI_COMMIT_REF_SLUG
    # 1151242 is the id of the "backend's" sub-repository id
    - curl --request DELETE --header "PRIVATE-TOKEN:$GITLAB_COM_API_TOKEN"
      https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/registry/repositories/1151242/tags/$CI_COMMIT_REF_SLUG
    # 1196730 is the id of the "epf's" sub-repository id
    - curl --request DELETE --header "PRIVATE-TOKEN:$GITLAB_COM_API_TOKEN"
      https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/registry/repositories/1196730/tags/$CI_COMMIT_REF_SLUG
  after_script:
    # remove the data backup from s3 (if it exists)
    - aws s3 rm "s3://$S3_DATA_BUCKET/mlreef-data-$CI_COMMIT_REF_SLUG.zip"
  environment:
    name: $CI_COMMIT_REF_SLUG
    action: stop


backup branch:
  extends: [.feature-branches-only]
  stage: maintenance
  when: manual
  image: registry.gitlab.com/systemkern/s5:latest-aws
  before_script:
    - URL=$(cat out/instance.info)
    - echo $URL                                            # debug output
    - chmod 400 $SSH_KEYFILE                               # prepare private key file
    - chmod +x $BACKUP_SCRIPT
    - sed -i "s~AWS_ACCESS_KEY_ID=XXXXX~AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID~"                  $BACKUP_SCRIPT
    - sed -i "s~AWS_SECRET_ACCESS_KEY=XXXXX~AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY~"      $BACKUP_SCRIPT
  script:
    - bin/ci-backup --instance $URL --bucket $S3_DATA_BUCKET --file mlreef-data-$CI_COMMIT_REF_SLUG.tar


restore from develop:
  extends: [.feature-branches-only]
  stage: maintenance
  when: manual
  image: registry.gitlab.com/systemkern/s5:latest-aws
  before_script:
    - URL=$(cat out/instance.info)
    - echo $URL                                            # debug output
    - chmod 400 $SSH_KEYFILE                               # prepare private key file
    - chmod +x $RESTORE_SCRIPT
    - sed -i "s~AWS_ACCESS_KEY_ID=XXXXX~AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID~"                  $RESTORE_SCRIPT
    - sed -i "s~AWS_SECRET_ACCESS_KEY=XXXXX~AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY~"      $RESTORE_SCRIPT
  script: ci-restore --instance $URL --bucket $S3_DATA_BUCKET --file mlreef-data-develop.tar
  except:
    refs:
      - master


restore branch backup:
  extends: [.feature-branches-only, "restore from develop"]
  script: ci-restore --instance $URL --bucket $S3_DATA_BUCKET --file mlreef-data-$CI_COMMIT_REF_SLUG.tar
