# This file contains the build and deployment configuration of MLReef.
image: alpine:latest                                       # default image for ci jobs

stages:
  - prepare
  - build
  - deploy
  - maintenance


# The deployment on aws depends on three main environment variables
# AWS_ACCESS_KEY_ID       create at https://console.aws.amazon.com/iam/
# AWS_SECRET_ACCESS_KEY   create at https://console.aws.amazon.com/iam/
# AWS_DEFAULT_REGION      default:eu-central-1
# GITLAB_API_TOKEN        for creating and deleting environments on gitlab.com
variables:
  FRONTEND_IMAGE_NAME:  "frontend"                         # docker image base name
  FRONTEND_TAG:         "$CI_COMMIT_REF_SLUG"              # must be the same as "tag" in in FRONTEND_IMAGE_PATH
  # unfortunately using the $FRONTEND_TAG variable inside the FRONTEND_IMAGE_PATH does not work
  FRONTEND_IMAGE_PATH:  "$DOCKER_REGISTRY/$DOCKER_ORGANISATION/$FRONTEND_IMAGE_NAME:$CI_COMMIT_REF_SLUG"
  BACKEND_IMAGE_NAME:   "backend"                          # docker image base name
  BACKEND_TAG:          "latest"
  BACKEND_IMAGE_PATH:   "$DOCKER_REGISTRY/$DOCKER_ORGANISATION/$BACKEND_IMAGE_NAME:$BACKEND_TAG"
  DOCKER_REGISTRY_REPO: "717423"                           # https://gitlab.com/api/v4/projects/12894267/registry/repositories/
  EC2_INSTANCE_NAME:    "mlreef-$CI_COMMIT_REF_SLUG"       # environment name and url are set separately
  SSH_KEYFILE:          "development.pem"
  STARTUP_SCRIPT:       "bin/startup.sh"
  BACKUP_SCRIPT:        "bin/backup.sh"
  RESTORE_SCRIPT:       "bin/restore.sh"
  DOCKER_COMPOSE:       "docker-compose.yml"
  INSTANCE_INFO:        "instance.info"                    # file for transmitting VM information between stages
  S3_DATA_BUCKET:       "mlreef-application-data"          # see also ec2 startup script
  DATA_ARCHIVE:         "mlreef-data-develop.zip"


terraform:
  stage: prepare
  image: registry.gitlab.com/systemkern/s5:latest-aws
  variables:
    EC2_MACHINE_SIZE:  "t3a.large"                         # https://aws.amazon.com/ec2/instance-types/
    EC2_IMAGE_AMI:     "ami-050a22b7e0cf85dd0"             # ubuntu 16.04 LTS
    EC2_SECURITY_GRP:  "application-servers"
    STARTUP_SCRIPT:    "src/terraform/startup.sh"
  before_script:
    # if on develop, deploy a larger instance
    - if [ $CI_COMMIT_REF_SLUG == "develop" ]; then EC2_MACHINE_SIZE="p2.xlarge"; fi
    - chmod 400 $SSH_KEYFILE                 # prepare private key file

    - export TF_VAR_environment_name=$EC2_INSTANCE_NAME
    - export TF_VAR_instance_type=$EC2_MACHINE_SIZE

    - sed -i "s~master/bin~$CI_COMMIT_REF_NAME/bin~"                                           $STARTUP_SCRIPT
    - sed -i "s~AWS_ACCESS_KEY_ID=XXXXX~AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID~"                 $STARTUP_SCRIPT
    - sed -i "s~AWS_SECRET_ACCESS_KEY=XXXXX~AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY~"     $STARTUP_SCRIPT
    - cat $STARTUP_SCRIPT
    - aws configure set aws_access_key_id     $AWS_ACCESS_KEY_ID
    - aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
    - aws configure set default.region        eu-central-1
    - ls -al ~/.aws/
    - cat ~/.aws/credentials
  script:
    - echo $TF_VAR_environment_name
    - cd src/terraform
    - terraform init    -input=false
    - terraform apply   -auto-approve
    - ls -al
    - aws ec2 describe-instances --filters "Name=tag:Name,Values=$TF_VAR_environment_name"
      | jq -r ".Reservations[].Instances[].InstanceId"
      | xargs --no-run-if-empty -I {} aws ec2 describe-instances --filters "Name=instance-id,Values={}"
      | jq -r ".Reservations[].Instances[].NetworkInterfaces[].Association.PublicDnsName"
      | head -1
      | tr -d '\r' > $INSTANCE_INFO                        # pass instance url to deploy stage
    - cat $INSTANCE_INFO                                   # debug output
    - mv instance.info ../../instance.info
  after_script:
    - cat $INSTANCE_INFO                                   # debug output
    - if [ -n $INSTANCE ]; then exit 1;  fi                # error on invalid INSTANCE_INFO
  artifacts:
    paths:
      - "$INSTANCE_INFO"                                   # pass the file which contains our instance URL
  environment:
    name: $CI_COMMIT_REF_SLUG
    url: $CI_PIPELINE_URL                                  # temporary url will be corrected by the gitlab-env-conf job
    on_stop: decommission                                  # clean up after branch merge
  only:
    refs:
      - master
      - develop

# The provision job boots up the new ec2 instance for deploying MLReef
provision ec2:
  stage: prepare
  image: registry.gitlab.com/systemkern/s5:latest-aws
  variables:
    EC2_MACHINE_SIZE:  "t3a.medium"                        # https://aws.amazon.com/ec2/instance-types/
    EC2_IMAGE_AMI:     "ami-050a22b7e0cf85dd0"             # ubuntu 16.04 LTS
    EC2_SECURITY_GRP:  "application-servers"
  before_script:
    # if on develop, deploy a larger instance
    - chmod 400 $SSH_KEYFILE                 # prepare private key file

    # decommission the current environment
    # use the aws-cli to retrieve the description (json) for our machine
    # parse the json with jq to get the instance id
    # the xargs command submits the termination command to AWS
    - aws ec2 describe-instances --filters "Name=tag:Name,Values=$EC2_INSTANCE_NAME"
      | jq -r ".Reservations[].Instances[].InstanceId"
      | xargs --no-run-if-empty aws ec2 terminate-instances --instance-id

    - sed -i "s~master/bin~$CI_COMMIT_REF_NAME/bin~"                                           $STARTUP_SCRIPT
    - sed -i "s~AWS_ACCESS_KEY_ID=XXXXX~AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID~"                 $STARTUP_SCRIPT
    - sed -i "s~AWS_SECRET_ACCESS_KEY=XXXXX~AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY~"     $STARTUP_SCRIPT
    - cat $STARTUP_SCRIPT
  script:
     # aws ec2 run instances documentation
     # https://docs.aws.amazon.com/cli/latest/reference/ec2/run-instances.html
     #   --credit-specification CpuCredits=standard
    - aws ec2 run-instances --count 1
      --region ${AWS_DEFAULT_REGION}
      --image-id ${EC2_IMAGE_AMI}
      --instance-type ${EC2_MACHINE_SIZE}
      --security-groups ${EC2_SECURITY_GRP}
      --key-name development
      --user-data file://"${STARTUP_SCRIPT}"
      --block-device-mappings file://bin/block-device-mappings.json
      --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=$EC2_INSTANCE_NAME}]"
      | jq -r ".Instances[].InstanceId"
      | xargs --no-run-if-empty -I {} aws ec2 describe-instances --filters "Name=instance-id,Values={}"
      | jq -r ".Reservations[].Instances[].NetworkInterfaces[].Association.PublicDnsName"
      | tr -d '\r' > $INSTANCE_INFO                        # pass instance url to deploy stage
  after_script:
    - cat $INSTANCE_INFO                                   # debug output
    - if [ -n $INSTANCE ]; then exit 1;  fi                # error on invalid INSTANCE_INFO
  artifacts:
    paths:
      - "$INSTANCE_INFO"                                   # pass the file which contains our instance URL
  environment:
    name: $CI_COMMIT_REF_SLUG
    url: $CI_PIPELINE_URL                                  # temporary url will be corrected by the gitlab-env-conf job
    on_stop: decommission                                  # clean up after branch merge
  except:
    refs:
      - develop
      - master


prepare npm:
  stage: prepare
  image: node:13.2.0-alpine                                # https://hub.docker.com/_/node/
  cache:
    key: mlreef-npm-cache
    paths:
      - /usr/local/lib/node_modules
      - web/node_modules
  before_script:
    - ls -al /usr/local/lib/node_modules
  script:
    - cd web
    - pwd && ls -al
    - npm install --global --silent react-scripts
    - npm install --global --silent create-react-app@latest
    - npm install --global --silent react-scripts@3.0.1
    - npm install --silent .
    - cp -r /usr/local/lib/node_modules ../node_modules_global
  after_script:
    - ls -al /usr/local/lib/node_modules
    - ls -al node_modules_global
  artifacts:
    expire_in: 3 days
    paths:
      - web/node_modules
      - node_modules_global


build frontend:
  image: docker:19.03.5                                    # https://hub.docker.com/_/docker/
  stage: build
  services:
    - docker:dind
  before_script:
    - docker login ${DOCKER_REGISTRY} -u "${DOCKER_USER}" -p "${DOCKER_PASSWORD}"
    - URL=$(cat $INSTANCE_INFO)
    - echo $URL                                             # debug output
    - mv node_modules_global web/node_modules_global
    - rm -rf web/package-lock.json
    - rm -rf web/node_modules
    - ls -al web/src
    - echo "REACT_APP_BACKEND=http://$URL" >> web/.env
    - cat web/.env
  script:
    - cd web
    - echo "creating docker image ${IMAGE_NAME} for user ${DOCKER_USER}"
    - docker build --pull --tag "$FRONTEND_IMAGE_PATH" -f Dockerfile .
    - docker push "${FRONTEND_IMAGE_PATH}"

# This job adds the actual frontend URL to the Environments GUI in gitlab.com
deploy:
  image: registry.gitlab.com/systemkern/s5:latest
  stage: deploy
  variables:
    KEY: "Authorization:"                                  # workaround to preserver the yaml structure
    GITLAB_PORT: 10080
  before_script:
    - echo "CI_COMMIT_REF_SLUG  is $CI_COMMIT_REF_SLUG"
    - echo "FRONTEND_TAG        is $FRONTEND_TAG"
    - echo "BACKEND_TAG         is $BACKEND_TAG"
    - echo "FRONTEND_IMAGE_NAME is $FRONTEND_IMAGE_NAME"
    - echo "BACKEND_IMAGE_NAME  is $BACKEND_IMAGE_NAME"
    - echo "FRONTEND_IMAGE_PATH is $FRONTEND_IMAGE_PATH"
    - echo "BACKEND_IMAGE_PATH  is $BACKEND_IMAGE_PATH"

    - URL=$(cat $INSTANCE_INFO)
    - echo $URL                                            # debug output
    - chmod 400 $SSH_KEYFILE                               # prepare private key file
    - chmod +x bin/*
    # rewrite docker dompose file
    # change the frontend docker image from develop branch to current branch
    - sed -i "s/$FRONTEND_IMAGE_NAME:develop/$FRONTEND_IMAGE_NAME:$FRONTEND_TAG/" $DOCKER_COMPOSE
    # change the frontend docker image from develop branch to current branch
    - sed -i "s/$BACKEND_IMAGE_NAME:develop/$BACKEND_IMAGE_NAME:$BACKEND_TAG/"    $DOCKER_COMPOSE
    # reactivate deactivated lines
    - sed -i "s~#CI_REMOVE~~"                                                     $DOCKER_COMPOSE

    - sed -i "s/GITLAB_HOST=gitlab/GITLAB_HOST=$URL/"                         $DOCKER_COMPOSE
    - sed -i "s/GITLAB_PORT=80/GITLAB_PORT=10080/"                            $DOCKER_COMPOSE
    - cat $DOCKER_COMPOSE
  script:
    - ssh-keyscan -H "$URL" >>~/.ssh/known_hosts
    # upload modified docker-compose to ec2 instance
    - scp -i $SSH_KEYFILE -o 'AddKeysToAgent yes' $DOCKER_COMPOSE ubuntu@${URL}:/home/ubuntu
    - scp -i $SSH_KEYFILE -o 'AddKeysToAgent yes' bin/deploy.sh ubuntu@${URL}:/home/ubuntu
    - ssh -i $SSH_KEYFILE -o 'AddKeysToAgent yes' ubuntu@"${URL}" "mkdir -p /home/ubuntu/bin"
    - scp -i $SSH_KEYFILE -o 'AddKeysToAgent yes' bin/setup-gitlab.sh ubuntu@${URL}:/home/ubuntu/bin
    - scp -i $SSH_KEYFILE -o 'AddKeysToAgent yes' ./bin/nginx_proxy.conf ubuntu@${URL}:/home/ubuntu/bin/nginx_proxy.conf
    - echo "starting deploy.sh"
    - echo "----------------------------------------"
    - ssh -i $SSH_KEYFILE -o 'AddKeysToAgent yes' ubuntu@"${URL}" "
        sudo docker login ${DOCKER_REGISTRY} -u \"${DOCKER_USER}\" -p \"${DOCKER_PASSWORD}\"
      "
    - ssh -i $SSH_KEYFILE -o 'AddKeysToAgent yes' ubuntu@"${URL}" "
      sudo ./deploy.sh
        --instance $URL
        --file $FRONTEND_IMAGE_PATH
        --port $GITLAB_PORT
        --key $AWS_ACCESS_KEY_ID
        --secret $AWS_SECRET_ACCESS_KEY
      "

gitlab env config:
  image: registry.gitlab.com/systemkern/s5:latest
  stage: deploy
  variables:
    KEY: "Authorization:"                                  # workaround to preserver the yaml structure
    GITLAB_PORT: 10080
  before_script:
    - URL=$(cat $INSTANCE_INFO)
    - echo $URL                                            # debug output
  script:
    # Get the ID of the gitlab environment we want to edit
    - ID=$(curl --fail
      --header "$KEY Bearer $GITLAB_API_TOKEN"
      https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/environments?name=$CI_COMMIT_REF_SLUG
      | jq -c '.[] | select(.name | contains("'$CI_REF_SLUG'")) | .id'
      )
    - echo "ID is $ID"                                      # debug output
    # configure the gitlab environment with the correct URL
    - curl --request PUT --fail
      --header "$KEY Bearer $GITLAB_API_TOKEN"
      --data "name=$CI_COMMIT_REF_SLUG&external_url=http://$URL"
      https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/environments/$ID


# The decommission job is configured by the provision's job `on_stop` command.
# The execution of decommission is triggered by merging or deleting a branch.
decommission:
  when: manual
  image: registry.gitlab.com/systemkern/s5:latest-aws
  stage: maintenance
  variables:
    GIT_STRATEGY: "none"                                   # because branches are deleted on merge, we must not access the git repo
    # workaround for YAML structure incompatibility https://gitlab.com/gitlab-org/gitlab-runner/issues/1809
    WORKAROUND: "PRIVATE-TOKEN:"                           # workaround to not break the yaml structure
  script:
    # decommission the current environment
    # use the aws-cli to retrieve the description (json) for our machine
    # parse the json with jq to get the instance id
    # the xargs command submits the termination command to AWS
    - aws ec2 describe-instances --filters "Name=tag:Name,Values=$EC2_INSTANCE_NAME"
      | jq -r ".Reservations[].Instances[].InstanceId"
      | xargs --no-run-if-empty aws ec2 terminate-instances --instance-id

    # remove the branch's frontend docker container
    - echo "Delete URL is https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/registry/repositories/$DOCKER_REGISTRY_REPO/tags/$CI_COMMIT_REF_SLUG/"
    - curl --request DELETE --header "$WORKAROUND $GITLAB_API_TOKEN" --fail
      https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/registry/repositories/$DOCKER_REGISTRY_REPO/tags/$CI_COMMIT_REF_SLUG
  after_script:
    # remove the data backup from s3 (if it exists)
    - aws s3 rm "s3://$S3_DATA_BUCKET/mlreef-data-$CI_COMMIT_REF_SLUG.zip"
  environment:
    name: $CI_COMMIT_REF_SLUG
    action: stop
  except:
    refs:
      - develop
      - master

backup branch:
  image: registry.gitlab.com/systemkern/s5:latest-aws
  stage: maintenance
  when: manual
  before_script:
    - URL=$(cat $INSTANCE_INFO)
    - echo $URL                                            # debug output
    - chmod 400 $SSH_KEYFILE                               # prepare private key file
    - chmod +x $BACKUP_SCRIPT
    - sed -i "s~AWS_ACCESS_KEY_ID=XXXXX~AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID~"                  $BACKUP_SCRIPT
    - sed -i "s~AWS_SECRET_ACCESS_KEY=XXXXX~AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY~"      $BACKUP_SCRIPT
  script:
    - $BACKUP_SCRIPT --instance $URL --bucket $S3_DATA_BUCKET --file mlreef-data-$CI_COMMIT_REF_SLUG.zip


restore from develop:
  image: registry.gitlab.com/systemkern/s5:latest-aws
  stage: maintenance
  when: manual
  before_script:
    - URL=$(cat $INSTANCE_INFO)
    - echo $URL                                            # debug output
    - chmod 400 $SSH_KEYFILE                               # prepare private key file
    - chmod +x $BACKUP_SCRIPT
    - sed -i "s~AWS_ACCESS_KEY_ID=XXXXX~AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID~"                  $RESTORE_SCRIPT
    - sed -i "s~AWS_SECRET_ACCESS_KEY=XXXXX~AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY~"      $RESTORE_SCRIPT
  script:
    - $RESTORE_SCRIPT $URL
  except:
    refs:
      - master

restore branch backup:
  extends: restore from develop
  script:
    - sed -i "s/INIT_ZIP=mlreef-data-develop.zip/INIT_ZIP=mlreef-data-$CI_COMMIT_REF_SLUG.zip/" $RESTORE_SCRIPT
    - $RESTORE_SCRIPT $URL
  except:
    refs:
      - develop
