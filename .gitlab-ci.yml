image: alpine:latest

stages:
  - prepare
  - deploy
  - teardown

# The deployment on aws depends on thre main environment variables
# AWS_ACCESS_KEY_ID       create at https://console.aws.amazon.com/iam/
# AWS_SECRET_ACCESS_KEY   create at https://console.aws.amazon.com/iam/
# AWS_DEFAULT_REGION      default:eu-central-1
variables:
  BUILD_PATH: "web/build"
  IMAGE_NAME: "frontend"
  FRONTEND_INSTANCE_NAME: frontend-$CI_COMMIT_REF_SLUG     # environment name and url are set separately
  GITLAB_EC2_INSTANCE_NAME: gitlab-$CI_COMMIT_REF_SLUG     # environment name and url are set separately
  FRONTEND_INSTANCE: frontend.instance                     # file for transmitting VM information between stages
  GITLAB_INSTANCE:   gitlab.instance                       # file for transmitting VM information between stages
  DOCKER_REGISTRY_REPOSITORY_ID: "717423"                  # https://gitlab.com/api/v4/projects/12894267/registry/repositories/
  IMAGE_PATH: "$DOCKER_REGISTRY/$DOCKER_ORGANISATION/$IMAGE_NAME:$CI_COMMIT_REF_SLUG"


# "." hides the job from execution
build:
  image: docker:latest
  stage: prepare
  services:
    - docker:dind
  before_script:
    - docker login ${DOCKER_REGISTRY} -u "${DOCKER_USER}" -p "${DOCKER_PASSWORD}"
  script:
    - cd web
    - rm -rf package-lock.json
    - rm -rf node_modules
    - echo "creating docker image ${IMAGE_NAME} for user ${DOCKER_USER}"
    - docker build --pull --tag "$IMAGE_PATH" -f Dockerfile .
    - docker push "${IMAGE_PATH}"

provision-gitlab:
  stage: prepare
  when: always
  image: registry.gitlab.com/systemkern/s5:latest-aws
  variables:
    EC2_IMAGE_AMI:     "ami-050a22b7e0cf85dd0"              # ubuntu 16.04 LTS
    EC2_MACHINE_SIZE:  "m4.xlarge"
    EC2_SECURITY_GRP:  "application_servers"
    STARTUP_SCRIPT:    "bin/gitlab-startup.sh"
  before_script:
    - chmod 400 development_deployment.pem                  # prepare private key file
    - bin/decomission.sh $GITLAB_EC2_INSTANCE_NAME          # first shutdown all current instances
  script:
    - INSTANCE=$(./bin/provision-gitlab.sh $GITLAB_EC2_INSTANCE_NAME $STARTUP_SCRIPT)
    - echo "$INSTANCE"
    - echo "$INSTANCE" | tr -d '\r' > $GITLAB_INSTANCE      # pass instance url to deploy stage
  after_script:
    - cat $GITLAB_INSTANCE
    - if [ $GITLAB_INSTANCE == "null" ]; then exit 1;  fi   # error on invalid INSTANCE_INFO
  artifacts:
    paths:
      - "$GITLAB_INSTANCE"                                  # pass the file which contains our instance URL

provision-frontend:
  image: registry.gitlab.com/systemkern/s5:latest-aws
  stage: prepare
  variables:
    EC2_IMAGE_AMI:    "ami-03c87d96f6702a119"               # aws-elasticbeanstalk-amzn-2018.03.0.x86_64-nodejs-hvm-201904170656
    EC2_MACHINE_SIZE: "t2.nano"                             # https://aws.amazon.com/ec2/instance-types/
    EC2_SECURITY_GRP: "application_servers"
  before_script:
    - chmod 400 development_deployment.pem                  # prepare private key file
    - ./bin/decomission.sh $FRONTEND_INSTANCE_NAME          # first shutdown all current instances
  script:
    - echo "FRONTEND_INSTANCE_NAME $FRONTEND_INSTANCE_NAME"
    - INSTANCE=$(./bin/provision-frontend.sh $FRONTEND_INSTANCE_NAME)
    - echo "$INSTANCE"
    - echo "$INSTANCE" | tr -d '\r' > $FRONTEND_INSTANCE    # pass instance url to deploy stage
  after_script:
    - cat $FRONTEND_INSTANCE
    - if [ $FRONTEND_INSTANCE == "null" ]; then exit 1;  fi # error on invalid INSTANCE_INFO
  artifacts:
    paths:
      - "$FRONTEND_INSTANCE"                                # pass the file which contains our instance URL
  environment:
    name: $CI_COMMIT_REF_SLUG
    url: $CI_PIPELINE_URL	                            # temporary url will be corrected by the gitlab-env-conf job
    on_stop: decomission                                # clean up after branch merge



# This job adds the actual frontend URL to the Environments GUI in gitlab.com
gitlab-env-conf:
  image: registry.gitlab.com/systemkern/s5:latest
  stage: deploy
  variables:
    GIT_STRATEGY: none
    KEY: "Authorization:"                                   # workaround to preserver the yaml structure
  before_script:
    - cat $FRONTEND_INSTANCE                                # debug output
    - URL=$(cat $FRONTEND_INSTANCE)
  script:
    # Get the ID of the gitlab environment we want to edit
    - ID=$(curl --header "$KEY Bearer $GITLAB_API_TOKEN"
      https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/environments?name=$CI_COMMIT_REF_SLUG
      | jq -c '.[] | select(.name | contains("'$CI_REF_SLUG'")) | .id'
      )
    - echo "ID is $ID"                                      # debug output
    # configure the gitlab environment with the correct URL
    - curl --request PUT --header "$KEY Bearer $GITLAB_API_TOKEN"
      --data "name=$CI_COMMIT_REF_SLUG&external_url=http://$URL:3000"
      https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/environments/$ID

# deploy the application to the ec2 instance
deploy-ec2:
  image: registry.gitlab.com/systemkern/s5:latest
  stage: deploy
  before_script:
    - cat $FRONTEND_INSTANCE
    - INSTANCE=$(cat $FRONTEND_INSTANCE)
    - chmod +x bin/jq
  script:
    - chmod 400 development_deployment.pem                  # prepare private key file
    - bin/deploy.sh $INSTANCE $IMAGE_PATH


decomission:
  when: manual
  image: registry.gitlab.com/systemkern/s5:latest-aws
  stage: teardown
  variables:
    GIT_STRATEGY: none
    # Workaround for Gitlab Bug https://gitlab.com/gitlab-org/gitlab-runner/issues/1809
    WORKAROUND: "PRIVATE-TOKEN:" # workaround to not break the yaml structure
  script:
    # use the aws-cli to retrieve the description (json) for our machine
    # parse the json with jq to get the instance id
    # the xargs command at the end submits the termination command to AWS
    - aws ec2 describe-instances
      --filters "Name=tag:Name,Values=$FRONTEND_INSTANCE_NAME"
      | jq -r ".Reservations[].Instances[].InstanceId"
      | xargs --no-run-if-empty aws ec2 terminate-instances
      --instance-id
    - aws ec2 describe-instances
      --filters "Name=tag:Name,Values=$GITLAB_EC2_INSTANCE_NAME"
      | jq -r ".Reservations[].Instances[].InstanceId"
      | xargs --no-run-if-empty aws ec2 terminate-instances
      --instance-id
    - curl --request DELETE --header "$WORKAROUND $GITLAB_API_TOKEN"
      https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/registry/repositories/$DOCKER_REGISTRY_REPOSITORY_ID/tags/$CI_COMMIT_REF_SLUG
  environment:
    name: $CI_COMMIT_REF_SLUG
    action: stop
  except:
    refs:
      - master
