include:
  - local: backend/.gitlab-ci.yml
  - local: epf/.gitlab-ci.yml
  - local: web/.gitlab-ci.yml

stages:
  - build
  - deploy
  - test
  - staging
  - maintenance

variables:
  S3_DATA_BUCKET:       "mlreef-application-data"          # see also ec2 startup script
  DATA_ARCHIVE:         "mlreef-data-master.zip"

.except-docu-branches:
  except:
    variables:
      # $CI_COMMIT_REF_NAME is the complete branch name e.g. "feature/my-cool-new-branch"
      - $CI_COMMIT_REF_NAME =~ /^doc\//                    # match every branch "doc/**"
      - $CI_COMMIT_REF_NAME =~ /^docs\//                   # match every branch "docs/**"
      - $CI_COMMIT_REF_NAME =~ /^docu\//                   # match every branch "docu/**"
      - $CI_COMMIT_REF_NAME =~ /^documentation\//          # match every branch "documentation/**"
      - $CI_COMMIT_REF_NAME =~ /^site\//                   # match every branch "site/**"


.only-on-code-changes: &run-on-all-code-changes
  only:
    changes:
      - backend/**/*
      - bin/ci-deploy
      - bin/install
      - bin/resources/runner-config*
      - epf/**/*
      - web/**/*
      - .gitlab-ci.yml
      - docker-compose.yml

.pages-code-changes: &run-on-pages-relevant-changes
  only:
    changes:
      - backend/**/*
      - docs/**/*
      - README.md



# provision boots up the new ec2 instance for deploying MLReef
provision:
  extends: [".except-docu-branches"]
  stage: build
  image: registry.gitlab.com/systemkern/s5:1-aws
  script: bin/ci-provision
  artifacts:
    paths:
      - out/instance.info             # pass instance url to later stages (see bin/includes/ci-environment)
  environment:
    name: $CI_COMMIT_REF_SLUG
    url: $CI_PIPELINE_URL
    on_stop: decommission             # clean up after branch merge
    auto_stop_in: 2 weeks




gitlab env config:
  extends: [".except-docu-branches"]
  stage: deploy
  needs: [provision]
  image: registry.gitlab.com/systemkern/s5:1-aws
  script:
    - INSTANCE_HOST=$(cat out/instance.info)
    - GITLAB_ROOT_URL=http://$INSTANCE_HOST
    - echo $INSTANCE_HOST
    - echo $GITLAB_ROOT_URL
    # Get the ID of the gitlab environment we want to edit
    - ID=$(curl --fail
      --header "Authorization:Bearer $GITLAB_COM_API_TOKEN"
      https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/environments?name=$CI_COMMIT_REF_SLUG
      | jq -c '.[] | select(.name | contains("'$CI_REF_SLUG'")) | .id'
      )
    - echo "ID is $ID"                                     # debug output
    # configure the gitlab environment with the correct URL
    - curl --request PUT --fail
      --header "Authorization:Bearer $GITLAB_COM_API_TOKEN"
      --data "name=$CI_COMMIT_REF_SLUG&external_url=$GITLAB_ROOT_URL/login"
      https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/environments/$ID


deploy:
  extends: [".except-docu-branches"]
  stage: deploy
  <<: *run-on-all-code-changes
  image: registry.gitlab.com/systemkern/s5:1-aws
  dependencies: [provision]                         # only copy artifacts from provision job
  script: bin/ci-deploy


# please do not move, adapt, delete, move to a include, whatever, if you did not read about the special "pages" job of gitlab ci
pages:
  image: node:10.19.0-alpine                                # https://hub.docker.com/_/node/
  stage: deploy
  <<: *run-on-pages-relevant-changes
  cache:
    key: pages-public-cache
    paths:
      - public/
      - /usr/local/lib/node_modules
      - docs/node_modules
  script: docs/bin/ci-pages
  artifacts:
    paths:
      - public

test rest docs are present:
  extends: [.except-docu-branches]
  stage: test
  <<: *run-on-pages-relevant-changes
  image: registry.gitlab.com/systemkern/s5:1
  allow_failure: true
  # See bin/ci-pages for the exact path to where rest docs are deployed
  script: |
    echo "Testing if backend rest-docs are available at https://mlreef.gitlab.io/mlreef/rest-api/$CI_COMMIT_BRANCH/index.html"
    echo "https://mlreef.gitlab.io/mlreef/rest-api/$CI_COMMIT_BRANCH/index.html"
    curl --fail --GET "https://mlreef.gitlab.io/mlreef/rest-api/$CI_COMMIT_BRANCH/index.html" > rest-docs-test.html
    ls -al

    # look for the specific error output of Spring Rest Docs
    #cat rest-docs-test.html | grep -e "not found for operation::" > missing.html
    #if [ -e missing.html ]; then
    #  cat missing.html  
    #  echo "MLReef rest-docs is missing some snippets :( "
    #  exit 1
    #fi
    #if [ -s missing.html ]; then
    #  echo "Yay, MLReef rest-docs is not missing snippets :) "
    #fi




smoke tests:
  extends: [.except-docu-branches]
  stage: test
  <<: *run-on-all-code-changes
  when: delayed
  start_in: 4 minutes
  image: registry.gitlab.com/systemkern/s5:latest-git
  script: bin/ci-smoke-tests


end2end tests:
  # import the centralised caching configuration for npm caches (from web/.gitlab-ci.yml)
  extends: [".except-docu-branches", ".npm-cache-config"]
  stage: test
  <<: *run-on-all-code-changes
  needs:
    - provision                                # artifacts from provision are needed
    - deploy                                   # wait for the deployment to be finished
  # The image should be the same image as web/Dockerfile and the "build frontend" job
  image: node:10.19.0-alpine
  script: web/bin/ci-run-end2end-tests


.system-tests:
  extends: [".except-docu-branches"]
  <<: *run-on-all-code-changes
  except:
    refs:
      - master
  stage: test
  image: java:8
  services:
    - docker:19.03.0-dind
  cache:
    key: "$CI_COMMIT_BRANCH"
    paths:
      - .gradle/wrapper
      - .gradle/caches
  variables:
    DOCKER_HOST: "tcp://docker:2375"  # gitlab needs this to support docker testcontainers
    DOCKER_DRIVER: overlay2           # gitlab needs this to support docker testcontainers
    DOCKER_TLS_CERTDIR: ""            # "/certs" gitlab needs this to support docker testcontainers

system tests:
  extends: [".system-tests"]
  allow_failure: false
  stage: test
  when: delayed
  start_in: 3 minutes
  script: backend/bin/ci-system-tests

pipeline tests:
  extends: [".system-tests"]
  allow_failure: true
  stage: test
  when: manual
  script: backend/bin/ci-pipeline-tests


staging:
  stage: staging
  only:
    refs:
      - master
  trigger: mlreef/infrastructure


# The decommission job is configured by the provision's job `on_stop` command.
# The execution of decommission is triggered by merging or deleting a branch.
# https://docs.gitlab.com/ee/ci/environments.html#automatically-stopping-an-environment
decommission:
  extends: [".feature-branches-only"]
  stage: maintenance
  when: manual
  image: registry.gitlab.com/systemkern/s5:latest-aws
  variables:
    GIT_STRATEGY: "none"                                    # because branches are deleted on merge, we must not access the git repo
  script:
    - EC2_INSTANCE_NAME="mlreef-$CI_COMMIT_REF_SLUG"

    # decommission the current environment
    # use the aws-cli to retrieve the description (json) for our machine
    # parse the json with jq to get the instance id
    # the xargs command submits the termination command to AWS
    - aws ec2 describe-instances --filters "Name=tag:Name,Values=$EC2_INSTANCE_NAME"
      | jq -r ".Reservations[].Instances[].InstanceId"
      | xargs --no-run-if-empty aws ec2 terminate-instances --instance-id

    # remove the branch's frontend docker container
    # 1117031 is the id of the "gateway's" sub-repository id
    - curl --request DELETE --header "PRIVATE-TOKEN:$GITLAB_COM_API_TOKEN"
      https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/registry/repositories/1117031/tags/$CI_COMMIT_REF_SLUG
    # 1151242 is the id of the "backend's" sub-repository id
    - curl --request DELETE --header "PRIVATE-TOKEN:$GITLAB_COM_API_TOKEN"
      https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/registry/repositories/1151242/tags/$CI_COMMIT_REF_SLUG
    # 1196730 is the id of the "epf's" sub-repository id
    - curl --request DELETE --header "PRIVATE-TOKEN:$GITLAB_COM_API_TOKEN"
      https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/registry/repositories/1196730/tags/$CI_COMMIT_REF_SLUG
  after_script:
    # remove the data backup from s3 (if it exists)
    - aws s3 rm "s3://$S3_DATA_BUCKET/mlreef-data-$CI_COMMIT_REF_SLUG.zip"
  environment:
    name: $CI_COMMIT_REF_SLUG
    action: stop


########### maintenance jobs ###########

.feature-branches-only:
  extends: [".except-docu-branches"]
  except:
    refs:
      - master

backup branch:
  extends: [.feature-branches-only]
  stage: maintenance
  when: manual
  image: registry.gitlab.com/systemkern/s5:1-aws
  before_script:
    - INSTANCE_HOST=$(cat out/instance.info)
    - echo $INSTANCE_HOST
    - chmod 400 $SSH_KEYFILE                               # prepare private key file
    - chmod +x $BACKUP_SCRIPT
    - sed -i "s~AWS_ACCESS_KEY_ID=XXXXX~AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID~"                  $BACKUP_SCRIPT
    - sed -i "s~AWS_SECRET_ACCESS_KEY=XXXXX~AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY~"      $BACKUP_SCRIPT
  script:
    - bin/ci-backup --instance $INSTANCE_HOST --bucket $S3_DATA_BUCKET --file mlreef-data-$CI_COMMIT_REF_SLUG.tar


restore from master:
  extends: [.feature-branches-only]
  stage: maintenance
  when: manual
  image: registry.gitlab.com/systemkern/s5:1-aws
  before_script:
    - INSTANCE_HOST=$(cat out/instance.info)
    - echo $INSTANCE_HOST                                            # debug output
    - chmod 400 $SSH_KEYFILE                               # prepare private key file
    - chmod +x $RESTORE_SCRIPT
    - sed -i "s~AWS_ACCESS_KEY_ID=XXXXX~AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID~"                  $RESTORE_SCRIPT
    - sed -i "s~AWS_SECRET_ACCESS_KEY=XXXXX~AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY~"      $RESTORE_SCRIPT
  script: ci-restore --instance $INSTANCE_HOST --bucket $S3_DATA_BUCKET --file mlreef-data-master.tar
  except:
    refs:
      - master


restore branch backup:
  extends: [.feature-branches-only, "restore from master"]
  script: ci-restore --instance $INSTANCE_HOST --bucket $S3_DATA_BUCKET --file mlreef-data-$CI_COMMIT_REF_SLUG.tar
